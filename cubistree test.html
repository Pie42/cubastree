<body>
    <style type="text/css">
        body{
            margin: 0;
            padding: 0
        }
        canvas{
            position: absolute; left: 0; top: 0;}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.0.0/gl-matrix-min.js"></script>
    <script>
        //creating the initial canvases. we need 2 of them because we get 2 different contexts(webgl, which is how all of the 3d stuff is rendered, and 2d, which is how the text is written). this just makes them and puts them on the page, and the css above makes it so that they are right on top of each other.
        //(function() {
        var canvas = document.createElement('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var rCanvas = document.createElement('canvas');
        rCanvas.width = window.innerWidth;
        rCanvas.height = window.innerHeight;
        document.body.appendChild(canvas);
        document.body.appendChild(rCanvas); //yeet
        //document.body.appendChild(canvas);
        //main();
        var renderlist = [],
            cubelist = [],
            particlelist = [],
            squareRotation = 0,
            pause = false,
            selection = void 0,
            selectThen = 0,
            then = 0,
            score = 0,
            combo = 1,
            comboThen = 0,
            click = false,
            mouse = {x: 0, y: 0},
            moveMouse = {x: 0, y: 0},
            prevRotation = glMatrix.quat.create(),
            lightPosition = glMatrix.vec3.create();
        glMatrix.vec3.set(lightPosition, -5.0, -5.0, 0.0);
        var ctx = rCanvas.getContext('2d'),
            time = 0,
            done = false;
        var xrot = 0,
            yrot = 0,
            zrot = 0;
        var xsensitivity = canvas.width / 10,
            ysensitivity = canvas.height / 10;
        var totRot = glMatrix.quat.create(),
            prevMouse = {x: 0, y: 0};
        //loading things in from local storage
        var highScore = (window.localStorage.highscore == void 0) ? 0 : window.localStorage.getItem('highscore'),
            bestTime = (window.localStorage.besttime == void 0) ? 999 + (59 * 1000) + (59 * 60 * 1000) + (99 * 60 * 60 * 1000) : window.localStorage.getItem('besttime'),
            cHighScore = (window.localStorage.chighscore == void 0) ? 0 : window.localStorage.getItem('chighscore'),
            cBestTime = (window.localStorage.cbesttime == void 0) ? 0 : window.localStorage.getItem('cbesttime'),
            loaded = 0,
            start = false,
            prevTouch = {x: 0, y: 0},
            resume = true,
            endFrames = [],
            dWidth = 0,
            xRatio = canvas.width / canvas.height,
            gameMode, //1 = normal, 2 = the other one
            addCubes = 4,
            otherPositions = [],
            addTime = 12000,
            addThen = 0,
            imagesLeft = new Array(54),
            imagesLeft2,
            funDOM = [],
            funDOMType;
        highScore = parseInt(highScore);
        bestTime = parseInt(bestTime);

        window.addEventListener("resize", function() {
            console.log('hi, you resized');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            rCanvas.width = window.innerWidth;
            rCanvas.height = window.innerHeight;
            xsensitivity = canvas.width / 10;
            ysensitivity = canvas.height / 10;
            ctx.font = "50px Courier New";
            xRatio = canvas.width / canvas.height;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            funDOMType = -1;
        });

        class particle {
            constructor(vector, x, y, z, texture, size, life, gl) {
                this.vector = vector;
                this.x = x;
                this.y = y;
                this.z = 10 + Math.random(); //the math.random() should hopefully prevent the textures from being on top of each other and looking weird
                this.texture = texture; //instead of loading in the textures every time, we can just have the cube use the texture as an argument and save time probably
                this.size = size;
                this.life = life;
                particlelist.push(this);
                this.buffers = this.createBuffers(gl);
                this.age = 0;
            }
            createBuffers(gl) {
                const positionBuffer = gl.createBuffer();

                // Select the positionBuffer as the one to apply buffer
                // operations to from here out.

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                const positions = [  
                    this.x - this.size, this.y - this.size, this.z, 
                    this.x - this.size, this.y + this.size, this.z,
                    this.x + this.size, this.y + this.size, this.z,
                    this.x + this.size, this.y - this.size, this.z,]; 
                //this.x + this.size, this.y + this.size, this.z,];
                gl.bufferData(gl.ARRAY_BUFFER,
                              new Float32Array(positions),
                              gl.STATIC_DRAW);

                const textureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
                const textureCoordinates = [
                    // Front
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,]
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                              gl.STATIC_DRAW);


                const normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

                const vertexNormals = [
                    0.0, 0.0, 1.0, 
                    0.0, 0.0, 1.0, 
                    0.0, 0.0, 1.0, 
                    0.0, 0.0, 1.0,
                ]
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals),
                              gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                // This array defines each face as two triangles, using the
                // indices into the vertex array to specify each triangle's
                // position.

                const indices = [
                    0,  1,  2,      0,  2,  3,    // front
                ];

                // Now send the element array to GL

                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                              new Uint16Array(indices), gl.STATIC_DRAW);
                return {
                    position: positionBuffer,
                    normal: normalBuffer,
                    textureCoord: textureCoordBuffer,
                    indices: indexBuffer,
                }
            }
        }

        class cube {
            constructor(x, y, z, image, gl, id, pnum) {
                this.x = x * 2;
                this.y = y * 2;
                this.z = z * 2;
                this.id = id;
                this.oid = id;
                this.pnum = pnum;
                this.gl = gl;
                this.buffers = this.createBuffers(this.gl);
                //this.texture = loadTexture(gl, image);
                this.texture = image;
                renderlist.push(this);
                cubelist.push(this);
            }

            explode() { //a pretty simple function that just makes a bunch of random particles. this function is called twice: when the cube is destroyed and at the very end.
                for (var i = 0; i < Math.floor(Math.random() * 5) + 7; i++) {
                    new particle([(Math.random() * 2) - 1, (Math.random() * 2) - 1], this.x, this.y, this.z, this.texture, Math.random() * 1.5, Math.floor(Math.random() * 50) + 75, this.gl);
                }
            }

            createBuffers(gl) {

                const positionBuffer = gl.createBuffer();

                // Select the positionBuffer as the one to apply buffer
                // operations to from here out.

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                const positions = [
                    // Front face
                    -1.0 + this.x, -1.0 + this.y,  1.0 + this.z,
                    1.0 + this.x, -1.0 + this.y,  1.0 + this.z,
                    1.0 + this.x,  1.0 + this.y,  1.0 + this.z,
                    -1.0 + this.x,  1.0 + this.y,  1.0 + this.z,

                    // Back face
                    -1.0 + this.x, -1.0 + this.y, -1.0 + this.z,
                    -1.0 + this.x,  1.0 + this.y, -1.0 + this.z,
                    1.0 + this.x,  1.0 + this.y, -1.0 + this.z,
                    1.0 + this.x, -1.0 + this.y, -1.0 + this.z,

                    // Top face
                    -1.0 + this.x,  1.0 + this.y, -1.0 + this.z,
                    -1.0 + this.x,  1.0 + this.y,  1.0 + this.z,
                    1.0 + this.x,  1.0 + this.y,  1.0 + this.z,
                    1.0 + this.x,  1.0 + this.y, -1.0 + this.z,

                    // Bottom face
                    -1.0 + this.x, -1.0 + this.y, -1.0 + this.z,
                    1.0 + this.x, -1.0 + this.y, -1.0 + this.z,
                    1.0 + this.x, -1.0 + this.y,  1.0 + this.z,
                    -1.0 + this.x, -1.0 + this.y,  1.0 + this.z,

                    // Right face
                    1.0 + this.x, -1.0 + this.y, -1.0 + this.z,
                    1.0 + this.x,  1.0 + this.y, -1.0 + this.z,
                    1.0 + this.x,  1.0 + this.y,  1.0 + this.z,
                    1.0 + this.x, -1.0 + this.y,  1.0 + this.z,

                    // Left face
                    -1.0 + this.x, -1.0 + this.y, -1.0 + this.z,
                    -1.0 + this.x, -1.0 + this.y,  1.0 + this.z,
                    -1.0 + this.x,  1.0 + this.y,  1.0 + this.z,
                    -1.0 + this.x,  1.0 + this.y, -1.0 + this.z,
                ];
                gl.bufferData(gl.ARRAY_BUFFER,
                              new Float32Array(positions),
                              gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                // This array defines each face as two triangles, using the
                // indices into the vertex array to specify each triangle's
                // position.

                const indices = [
                    0,  1,  2,      0,  2,  3,    // front
                    4,  5,  6,      4,  6,  7,    // back
                    8,  9,  10,     8,  10, 11,   // top
                    12, 13, 14,     12, 14, 15,   // bottom
                    16, 17, 18,     16, 18, 19,   // right
                    20, 21, 22,     20, 22, 23,   // left
                ];

                // Now send the element array to GL

                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                              new Uint16Array(indices), gl.STATIC_DRAW);

                const textureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);

                const textureCoordinates = [
                    // Front
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,
                    // Back
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,
                    // Top
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,
                    // Bottom
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,
                    // Right
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,
                    // Left
                    0.0,  0.0,
                    1.0,  0.0,
                    1.0,  1.0,
                    0.0,  1.0,
                ];

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                              gl.STATIC_DRAW);
                const colors = [
                    (this.id / 255), 0.0, 0.0, 1.0,
                ]
                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors),
                              gl.STATIC_DRAW);

                const normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

                const vertexNormals = [
                    // Front
                    0.0,  0.0,  1.0,
                    0.0,  0.0,  1.0,
                    0.0,  0.0,  1.0,
                    0.0,  0.0,  1.0,

                    // Back
                    0.0,  0.0, -1.0,
                    0.0,  0.0, -1.0,
                    0.0,  0.0, -1.0,
                    0.0,  0.0, -1.0,

                    // Top
                    0.0,  1.0,  0.0,
                    0.0,  1.0,  0.0,
                    0.0,  1.0,  0.0,
                    0.0,  1.0,  0.0,

                    // Bottom
                    0.0, -1.0,  0.0,
                    0.0, -1.0,  0.0,
                    0.0, -1.0,  0.0,
                    0.0, -1.0,  0.0,

                    // Right
                    1.0,  0.0,  0.0,
                    1.0,  0.0,  0.0,
                    1.0,  0.0,  0.0,
                    1.0,  0.0,  0.0,

                    // Left
                    -1.0,  0.0,  0.0,
                    -1.0,  0.0,  0.0,
                    -1.0,  0.0,  0.0,
                    -1.0,  0.0,  0.0
                ];

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals),
                              gl.STATIC_DRAW);

                return {
                    position: positionBuffer,
                    normal: normalBuffer,
                    textureCoord: textureCoordBuffer,
                    indices: indexBuffer,
                    colors: colorBuffer,
                };
            }
        }
        const gl = canvas.getContext('webgl');

        // If we don't have a GL context, give up now

        if (!gl) {
            alert('Unable to initialize WebGL. Your browser or machine may not support it.');
        }

        // Vertex shader program

        const vsSource = `
attribute vec4 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;

uniform mat4 uNormalMatrix;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uRotationMatrix;
uniform vec3 uLightPosition;

varying highp vec2 vTextureCoord;
varying highp vec3 vLighting;

void main(void) {
gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
vTextureCoord = aTextureCoord;

highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);
highp vec3 directionalLightColor = vec3(1, 1, 1);
//highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));
highp vec3 directionalVector = normalize(vec3(0.0, 0.0, 0.85));

highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

highp float directional = min(max(dot(transformedNormal.xyz, directionalVector), 0.0), 1.0);

highp vec3 lightDirection = vec3(0.0, 0.0, 1.0);
highp float lightConstant = 1.0;
highp float lightLinear = 0.0019;
highp float lightQuadratic = 0.00132;

//highp float distance = length(normalize(vec4(uLightPosition, 1.0)) - (uRotationMatrix * aVertexPosition));
highp float distance = length(vec4(uLightPosition, 1.0) - (uModelViewMatrix * aVertexPosition));
//highp float distance = length((uModelViewMatrix * aVertexPosition));
highp float attenuation = 1.0 / (lightConstant + (lightLinear * distance) + (lightQuadratic * (distance * distance)));

highp vec3 lightDir = normalize(uLightPosition - (uModelViewMatrix * aVertexPosition).xyz);
highp float theta = dot(lightDir, normalize(-lightDirection));
//vLighting = (ambientLight + (directionalLightColor * directional)) * attenuation * ((theta * theta * theta * theta * theta * theta * theta * theta * theta * theta * theta * theta * theta * theta * theta * theta) * 100000.0);

//"flashlight" code
/*if (theta < -0.999) {
vLighting = (ambientLight + (directionalLightColor * directional)) * attenuation;
}
else if (theta < -0.99) {
vLighting = (ambientLight + (directionalLightColor * directional)) * attenuation * ((-theta - 0.99) / (0.999 - 0.99));
}
else {
vLighting = vec3(0.01, 0.01, 0.01);
}*/
vLighting = (ambientLight + (directionalLightColor * directional)) * attenuation;
}
`;
        /*
    uniform vec3 uLightPosition;

    highp vec3 lightDirection = vec3(0.0, 0.0, 1.0);
    highp float lightConstant = 1.0;
    highp float lightLinear = 0.35;
    highp float lightQuadratic = 0.44;

    highp float distance = length(vec4(uLightPosition, 1.0) - aVertexPosition);
    highp float attenuation = 1.0 / (lightConstant + (lightLinear * distance) + (lightQuadratic * (distance * distance)));

    */
        /*
    // ambient
    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;

    // diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(light.position - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;  

    // specular
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;  

    // attenuation
    float distance    = length(light.position - FragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    

    ambient  *= attenuation;  
    diffuse   *= attenuation;
    specular *= attenuation;   

    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
    */
        /*`
    attribute vec4 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uNormalMatrix;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying highp vec2 vTextureCoord;
    varying highp vec3 vLighting;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vTextureCoord = aTextureCoord;

      // Apply lighting effect

      highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);
      highp vec3 directionalLightColor = vec3(1, 1, 1);
      highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));

      highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

      highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
      vLighting = ambientLight + (directionalLightColor * directional);
    }
  `;*/
        const fsSource1 = `
precision mediump float;
varying highp vec2 vTextureCoord;
varying highp vec3 vLighting;

uniform sampler2D uSampler;

void main(void) {
vec4 color = texture2D(uSampler, vTextureCoord);
gl_FragColor = vec4(color.rgb * vLighting, 1.0);
}
`;
        const fsSource2 = `
precision mediump float;
varying highp vec2 vTextureCoord;
varying highp vec3 vLighting;

uniform sampler2D uSampler;

void main(void) {
vec4 color = texture2D(uSampler, vTextureCoord);
gl_FragColor = vec4(color.rgb * vLighting, 0.5);
}
`;

        const sFragShader = `
precision mediump float;
uniform vec4 u_id;

void main() {
gl_FragColor = u_id;
}`;
        const sVertShader = `attribute vec4 a_position;

uniform mat4 u_p_matrix;
uniform mat4 u_m_matrix;

void main() {
// Multiply the position by the matrix.
gl_Position = u_p_matrix * u_m_matrix * a_position;
}`
        // Initialize a shader program; this is where all the lighting
        // for the vertices and so forth is established.
        const shaderProgram1 = initShaderProgram(gl, vsSource, fsSource1);
        const shaderProgram2 = initShaderProgram(gl, vsSource, fsSource2);
        const selectProgram = initShaderProgram(gl, sVertShader, sFragShader);

        // Collect all the info needed to use the shader program.
        // Look up which attribute our shader program is using
        // for aVertexPosition and look up uniform locations.
        const sProgramInfo = {
            program: selectProgram,
            attribLocations: {
                position: gl.getAttribLocation(selectProgram, 'a_position'),
            },
            uniformLocations: {
                id: gl.getUniformLocation(selectProgram, 'u_id'),
                p_matrix: gl.getUniformLocation(selectProgram, 'u_p_matrix'),
                m_matrix: gl.getUniformLocation(selectProgram, 'u_m_matrix'),
            },
        }
        const programInfo1 = {
            program: shaderProgram1,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram1, 'aVertexPosition'),
                vertexNormal: gl.getAttribLocation(shaderProgram1, 'aVertexNormal'),
                textureCoord: gl.getAttribLocation(shaderProgram1, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram1, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram1, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram1, 'uNormalMatrix'),
                lightPosition: gl.getUniformLocation(shaderProgram1, 'uLightPosition'),
                rotationMatrix: gl.getUniformLocation(shaderProgram1, 'uRotationMatrix'),
                uSampler: gl.getUniformLocation(shaderProgram1, 'uSampler'),
            },
        };
        const programInfo2 = {
            program: shaderProgram2,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram2, 'aVertexPosition'),
                vertexNormal: gl.getAttribLocation(shaderProgram2, 'aVertexNormal'),
                textureCoord: gl.getAttribLocation(shaderProgram2, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram2, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram2, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram2, 'uNormalMatrix'),
                lightPosition: gl.getUniformLocation(shaderProgram2, 'uLightPosition'),
                rotationMatrix: gl.getUniformLocation(shaderProgram2, 'uRotationMatrix'),
                uSampler: gl.getUniformLocation(shaderProgram2, 'uSampler'),
            },
        };
        var textures = [];
        for (var t = 1; t < 55; t++) {
            textures.push(loadTexture(gl, 'cubistree images/' + t.toString() + '.png'));
        }
        var coords = [];
        for (var i = -2.5; i < 3; i++) {
            for (var j = -2.5; j < 3; j++) {
                for (var k = -2.5; k < 3; k++) {
                    //otherPositions[JSON.stringify([i, j, k])] = true;
                    otherPositions.push([i, j, k]);
                    //coords.push([i, j, k]);
                }
            }
        }
        //otherPositions = new Array(...coords);
        /*let id = 1;
    for (var n = 1; n < 55; n++) {
        for (var u = 0; u < 4; u++) {
            let l = Math.floor(Math.random() * coords.length),
                m = coords[l];
            //new cube(...m, 'cubistree images/' + n.toString() + '.png', gl, id, n);
            new cube(...m, textures[n - 1], gl, id, n);
            id++;
            coords.splice(l, 1);
        }
    }*/ //-creating the full list of cubes. will be replaced by better things when there are more modes, since it's unnecessary
        // Draw the scene

        // Draw the scene repeatedly
        function render(now) {
            now *= 0.001;  // convert to seconds
            const deltaTime = now - then;
            then = now;

            start && drawScene(gl, programInfo1, programInfo2, deltaTime);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
        //}

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        function loadTexture(gl, url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Because images have to be download over the internet
            // they might take a moment until they are ready.
            // Until then put a single pixel in the texture so we can
            // use it immediately. When the image has finished downloading
            // we'll update the texture with the contents of the image.
            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                          width, height, border, srcFormat, srcType,
                          pixel);

            const image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                              srcFormat, srcType, image);
                gl.generateMipmap(gl.TEXTURE_2D);
                loaded++;
            };
            image.imageSmoothingEnabled = false;
            image.src = url;

            return texture;
        }

        function drawScene(gl, programInfo1, programInfo2, deltaTime) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


            // Create a perspective matrix, a special matrix that is
            // used to simulate the distortion of perspective in a camera.
            // Our field of view is 45 degrees, with a width/height
            // ratio that matches the display size of the canvas
            // and we only want to see objects between 0.1 units
            // and 100 units away from the camera.

            const fieldOfView = 45 * Math.PI / 180;   // in radians
            const aspect = canvas.width / canvas.height;
            const zNear = 0.01;
            const zFar = 100.0;
            const projectionMatrix = glMatrix.mat4.create();

            // note: glmatrix.js always has the first argument
            // as the destination to receive the result.
            glMatrix.mat4.perspective(projectionMatrix,
                                      fieldOfView,
                                      aspect,
                                      zNear,
                                      zFar);

            // Set the drawing position to the "identity" point, which is
            // the center of the scene.
            const modelViewMatrix = glMatrix.mat4.create();
            glMatrix.mat4.fromRotationTranslation(modelViewMatrix, totRot, [0, 0, -30]);
            const rotationMatrix = glMatrix.mat4.create();
            glMatrix.mat4.fromRotationTranslation(rotationMatrix, totRot, [0, 0, 0]);

            const normalMatrix = glMatrix.mat4.create();
            glMatrix.mat4.invert(normalMatrix, modelViewMatrix);
            glMatrix.mat4.transpose(normalMatrix, normalMatrix);

            // Tell WebGL how to pull out the positions from the position
            // buffer into the vertexPosition attribute.
            var scale = (Math.cos((then - selectThen) * 6) + 9) / 10;
            var num = -4;
            cubelist.forEach((element) => {
                let buffers = element.buffers,
                    texture = element.texture;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
                var tempModel = glMatrix.mat4.create();
                glMatrix.mat4.copy(tempModel, modelViewMatrix);
                (selection != void 0 && element.id == selection.id) && (glMatrix.mat4.translate(tempModel, tempModel, [(element.x), (element.y), (element.z)]), glMatrix.mat4.scale(tempModel, tempModel, [scale, scale, scale]), glMatrix.mat4.translate(tempModel, tempModel, [-1 * element.x, -1 * element.y, -1 * element.z]))
                {
                    const numComponents = 3;
                    const type = gl.FLOAT;
                    const normalize = false;
                    const stride = 0;
                    const offset = 0;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                    gl.vertexAttribPointer(
                        programInfo1.attribLocations.vertexPosition,
                        numComponents,
                        type,
                        normalize,
                        stride,
                        offset);
                    gl.enableVertexAttribArray(
                        programInfo1.attribLocations.vertexPosition);
                }
                // tell webgl how to pull out the texture coordinates from buffer
                {
                    const num = 2; // every coordinate composed of 2 values
                    const type = gl.FLOAT; // the data in the buffer is 32 bit float
                    const normalize = false; // don't normalize
                    const stride = 0; // how many bytes to get from one set to the next
                    const offset = 0; // how many bytes inside the buffer to start from
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
                    gl.vertexAttribPointer(programInfo1.attribLocations.textureCoord, num, type, normalize, stride, offset);
                    gl.enableVertexAttribArray(programInfo1.attribLocations.textureCoord);
                }

                {
                    const numComponents = 3;
                    const type = gl.FLOAT;
                    const normalize = false;
                    const stride = 0;
                    const offset = 0;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                    gl.vertexAttribPointer(
                        programInfo1.attribLocations.vertexNormal,
                        numComponents,
                        type,
                        normalize,
                        stride,
                        offset);
                    gl.enableVertexAttribArray(
                        programInfo1.attribLocations.vertexNormal);
                }

                gl.useProgram(programInfo1.program);
                // Tell WebGL we want to affect texture unit 0
                gl.activeTexture(gl.TEXTURE0);

                // Bind the texture to texture unit 0
                gl.bindTexture(gl.TEXTURE_2D, texture);

                // Tell the shader we bound the texture to texture unit 0
                gl.uniform1i(programInfo1.uniformLocations.uSampler, 0);
                //gl.uniform1f(programInfo1.uniformLocations.alpha, 1.0);

                // Tell WebGL to use our program when drawing



                // Set the shader uniforms

                gl.uniformMatrix4fv(
                    programInfo1.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix);
                gl.uniformMatrix4fv(
                    programInfo1.uniformLocations.modelViewMatrix,
                    false,
                    tempModel);
                gl.uniformMatrix4fv(
                    programInfo1.uniformLocations.rotationMatrix,
                    false,
                    rotationMatrix);

                gl.uniformMatrix4fv(
                    programInfo1.uniformLocations.normalMatrix,
                    false,
                    normalMatrix);

                gl.uniform3f(
                    programInfo1.uniformLocations.lightPosition,
                    //3,
                    ...lightPosition);
                {
                    const vertexCount = 36;
                    const type = gl.UNSIGNED_SHORT;
                    const offset = 0;
                    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
                }
            })
            const particleViewMatrix = glMatrix.mat4.create();

            // Now move the drawing position a bit to where we want to
            // start drawing the square.

            glMatrix.mat4.translate(particleViewMatrix,     // destination matrix
                                    particleViewMatrix,     // matrix to translate
                                    //[1.0, 1.0, -30.0]);  // amount to translate
                                    [0, 0, -30]);//*/

            const rotationMatrix2 = glMatrix.mat4.create();

            const normalMatrix2 = glMatrix.mat4.create();
            glMatrix.mat4.invert(normalMatrix2, particleViewMatrix);
            glMatrix.mat4.transpose(normalMatrix2, normalMatrix2);
            //glMatrix.mat4.fromRotationTranslation(particleViewMatrix, totRot, [0, 0, -30]);
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            particlelist.forEach((element, index) => {
                let buffers = element.buffers,
                    texture = element.texture;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
                var tempModel = glMatrix.mat4.create();

                glMatrix.mat4.copy(tempModel, particleViewMatrix);
                glMatrix.mat4.translate(tempModel, tempModel, [element.age * element.vector[0], element.age * element.vector[1], 0]);
                {
                    const numComponents = 3;
                    const type = gl.FLOAT;
                    const normalize = false;
                    const stride = 0;
                    const offset = 0;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                    gl.vertexAttribPointer(
                        programInfo2.attribLocations.vertexPosition,
                        numComponents,
                        type,
                        normalize,
                        stride,
                        offset);
                    gl.enableVertexAttribArray(
                        programInfo2.attribLocations.vertexPosition);
                }
                // tell webgl how to pull out the texture coordinates from buffer
                {
                    const num = 2; // every coordinate composed of 2 values
                    const type = gl.FLOAT; // the data in the buffer is 32 bit float
                    const normalize = false; // don't normalize
                    const stride = 0; // how many bytes to get from one set to the next
                    const offset = 0; // how many bytes inside the buffer to start from
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
                    gl.vertexAttribPointer(programInfo2.attribLocations.textureCoord, num, type, normalize, stride, offset);
                    gl.enableVertexAttribArray(programInfo2.attribLocations.textureCoord);
                }

                {
                    const numComponents = 3;
                    const type = gl.FLOAT;
                    const normalize = false;
                    const stride = 0;
                    const offset = 0;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                    gl.vertexAttribPointer(
                        programInfo2.attribLocations.vertexNormal,
                        numComponents,
                        type,
                        normalize,
                        stride,
                        offset);
                    gl.enableVertexAttribArray(
                        programInfo2.attribLocations.vertexNormal);
                }

                gl.useProgram(programInfo2.program);
                // Tell WebGL we want to affect texture unit 0
                gl.activeTexture(gl.TEXTURE0);

                // Bind the texture to texture unit 0
                gl.bindTexture(gl.TEXTURE_2D, texture);

                // Tell the shader we bound the texture to texture unit 0
                gl.uniform1i(programInfo2.uniformLocations.uSampler, 0);
                //gl.uniform1f(programInfo2.uniformLocations.alpha, 0.5);
                // Tell WebGL to use our program when drawing



                // Set the shader uniforms

                gl.uniformMatrix4fv(
                    programInfo2.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix);
                gl.uniformMatrix4fv(
                    programInfo2.uniformLocations.modelViewMatrix,
                    false,
                    tempModel);

                gl.uniformMatrix4fv(
                    programInfo2.uniformLocations.normalMatrix,
                    false,
                    normalMatrix);

                gl.uniformMatrix4fv(
                    programInfo2.uniformLocations.rotationMatrix,
                    false,
                    rotationMatrix2);

                gl.uniform3f(
                    programInfo2.uniformLocations.lightPosition,
                    //3,
                    ...lightPosition);

                {
                    const vertexCount = 6;
                    const type = gl.UNSIGNED_SHORT;
                    const offset = 0;
                    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
                }
                element.age++;
                (element.age > element.life) && (particlelist.splice(index, 1));
            })

            //if (!pause) {squareRotation += deltaTime}
        }
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object

            gl.shaderSource(shader, source);

            // Compile the shader program

            gl.compileShader(shader);

            // See if it compiled successfully

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }
        function getMousePosition(canvas, e) {
            var boundary = canvas.getBoundingClientRect();
            // (e.clientX, e.clientY)  => Mouse coordinates wrt whole browser
            //  (boundary.left, boundary.top) => Canvas starting coordinate
            return {
                x: e.clientX - boundary.left,  
                y: e.clientY - boundary.top
            };
        }
        //rCanvas.onclick = function(e) {
        document.body.addEventListener('mouseup', function(e) {
            click = false;
        });
        document.body.addEventListener('mousemove', function(e) {
            if (prevMouse.x == 0 && prevMouse.y == 0) {
                var deltaRot = {x: 0, y: 0}
                }
            else {
                var deltaRot = {
                    x: e.offsetX-prevMouse.x,
                    y: e.offsetY-prevMouse.y
                };
            }
            if (click) {
                let nMoveQuat = glMatrix.quat.create();
                glMatrix.quat.fromEuler(nMoveQuat, deltaRot.y * ysensitivity * (Math.PI / 180), deltaRot.x * xsensitivity * (Math.PI / 180), 0);
                glMatrix.quat.multiply(totRot, nMoveQuat, totRot);
            }
            prevMouse = {x: e.offsetX, y: e.offsetY};
            glMatrix.vec3.set(lightPosition, (((prevMouse.x / canvas.width) * 20 * xRatio) - (10 * xRatio)), (((prevMouse.y / canvas.height) * -20) + 10), 0.0);
        });
        document.body.addEventListener('touchmove', function(e) {
            if (prevTouch.x == 0 && prevTouch.y == 0) {
                var deltaTRot = {x: 0, y: 0}
                }
            else {
                var deltaTRot = {
                    x: e.touches[0].clientX-prevTouch.x,
                    y: e.touches[0].clientY-prevTouch.y
                };
            }
            if (click) {
                let nMoveQuat = glMatrix.quat.create();
                glMatrix.quat.fromEuler(nMoveQuat, deltaTRot.y * ysensitivity * (Math.PI / 180), deltaTRot.x * xsensitivity * (Math.PI / 180), 0);
                glMatrix.quat.multiply(totRot, nMoveQuat, totRot);
            }
            prevTouch = {x: e.touches[0].clientX, y: e.touches[0].clientY};
            glMatrix.vec3.set(lightPosition, (((prevTouch.x / canvas.width) * 10) - 5), (((prevTouch.y / canvas.height) * 10) - 5), 0.0);
        });
        document.body.addEventListener('touchstart', function(e){ e.preventDefault(); click = true; mouse = {x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY}; onceclick(e)});
        document.body.addEventListener('touchend', function(e){ click = false; prevTouch = {x: 0, y: 0}});
        document.body.addEventListener('mousedown', function(e) {
            click = true;
            mouse = getMousePosition(canvas, e);
            onceclick(e)})
        function onceclick(e) {
            if (start && resume) {
                if (mouse.x < rCanvas.width / 15 && mouse.x > rCanvas.width / 40 && mouse.y < 19 * rCanvas.height / 20 && mouse.y > 17 * rCanvas.height / 20) {
                    resume = false;
                }
                gl.clearColor(0.0, 0.0, 0.0, 0.0);  // Clear to black, fully opaque
                gl.clearDepth(1.0);                 // Clear everything
                gl.enable(gl.DEPTH_TEST);           // Enable depth testing
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

                // Clear the canvas before we start drawing on it.

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


                const fieldOfView = 45 * Math.PI / 180;   // in radians
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const zNear = 0.01;
                const zFar = 100.0;
                const projectionMatrix = glMatrix.mat4.create();

                // note: glmatrix.js always has the first argument
                // as the destination to receive the result.
                glMatrix.mat4.perspective(projectionMatrix,
                                          fieldOfView,
                                          aspect,
                                          zNear,
                                          zFar);

                // Set the drawing position to the "identity" point, which is
                // the center of the scene.
                const modelViewMatrix = glMatrix.mat4.create();
                glMatrix.mat4.fromRotationTranslation(modelViewMatrix, totRot, [0, 0, -30]);
                cubelist.forEach((element) => {
                    let buffers = element.buffers;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
                    {
                        const numComponents = 3;
                        const type = gl.FLOAT;
                        const normalize = false;
                        const stride = 0;
                        const offset = 0;
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                        gl.vertexAttribPointer(
                            sProgramInfo.attribLocations.position,
                            numComponents,
                            type,
                            normalize,
                            stride,
                            offset);
                        gl.enableVertexAttribArray(
                            sProgramInfo.attribLocations.position);
                    }
                    gl.useProgram(sProgramInfo.program);
                    gl.uniformMatrix4fv(
                        sProgramInfo.uniformLocations.p_matrix,
                        false,
                        projectionMatrix);
                    gl.uniformMatrix4fv(
                        sProgramInfo.uniformLocations.m_matrix,
                        false,
                        modelViewMatrix);

                    gl.uniform4f(sProgramInfo.uniformLocations.id, (element.id / 255), 0.0, 0.0, 1.0);
                    {
                        const vertexCount = 36;
                        const type = gl.UNSIGNED_SHORT;
                        const offset = 0;
                        gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
                    }
                });
                const pixelX = mouse.x * gl.canvas.width / gl.canvas.clientWidth;
                const pixelY = gl.canvas.height - mouse.y * gl.canvas.height / gl.canvas.clientHeight - 1;
                const data = new Uint8Array(4);
                gl.readPixels(
                    pixelX,            // x
                    pixelY,            // y
                    1,                 // width
                    1,                 // height
                    gl.RGBA,           // format
                    gl.UNSIGNED_BYTE,  // type
                    data);             // typed array to hold result
                const id = data[0];
                if (selection == undefined || id != selection.id) {
                    if (id > 0) {
                        cubelist.forEach((cube, index) => {
                            if (cube.id == id && (selection == void 0 || selection.pnum != cube.pnum)) { //if you aren't selecting something
                                selection = cube;
                                selectThen = then;
                            }
                            else if (cube.id == id && selection != void 0 && selection.pnum == cube.pnum) { //if you are selecting something
                                score += 10 * combo;
                                combo++;
                                comboThen = tThen;
                                if (gameMode == 2) {
                                    if (imagesLeft[cube.pnum] == 0) {
                                        imagesLeft2.push(cube.pnum);
                                    }
                                    imagesLeft[cube.pnum] += 2;
                                    otherPositions.push([cube.x / 2, cube.y / 2, cube.z / 2], [selection.x / 2, selection.y / 2, selection.z / 2]);
                                }
                                selection.explode(); //make particles
                                cube.explode();
                                if (id > selection.id) {
                                    cubelist.splice(id - 1, 1);
                                    for (var i = id - 1; i < cubelist.length; i++) {
                                        cubelist[i].id--;
                                    }
                                    cubelist.splice(selection.id - 1, 1);
                                    for (var i = selection.id - 1; i < cubelist.length; i++) {
                                        cubelist[i].id--;
                                    }
                                    selection = void 0;
                                }
                                else {
                                    cubelist.splice(selection.id - 1, 1);
                                    for (var i = selection.id - 1; i < cubelist.length; i++) {
                                        cubelist[i].id--;
                                    }
                                    cubelist.splice(id - 1, 1);
                                    for (var i = id - 1; i < cubelist.length; i++) {
                                        cubelist[i].id--;
                                    }
                                    selection = void 0;
                                }
                            }
                        });
                    }
                }
            }
            else if (!start) { //clicks in the start menuish
                //let tLength = ctx.measureText('Start');
                //if (mouse.x < (rCanvas.width / 2) + tLength.width / 2 && mouse.x > (rCanvas.width / 2) - tLength.width / 2 && mouse.y < (rCanvas.height / 2) + 8 && mouse.y > (rCanvas.height / 2) - 42) {
                //start = true;
                //}
                let tLength1 = ctx.measureText('Standard');
                if (mouse.x < (rCanvas.width / 2) + tLength1.width / 2 && mouse.x > (rCanvas.width / 2) - tLength1.width / 2 && mouse.y < (rCanvas.height / 3) + 8 && mouse.y > (rCanvas.height / 3) - 42) {
                    start = true;
                    gameMode = 1;
                    coords = [];
                    for (var i = -2.5; i < 3; i++) { //making a new cube
                        for (var j = -2.5; j < 3; j++) {
                            for (var k = -2.5; k < 3; k++) {
                                coords.push([i, j, k]);
                            }
                        }
                    }
                    let id = 1;
                    for (var n = 1; n < 55; n++) {
                        for (var u = 0; u < 4; u++) {
                            let l = Math.floor(Math.random() * coords.length),
                                m = coords[l],
                                p = [...m, textures[n - 1], gl, id, n]; //shh this fixes a bug so it's fine
                            try {new cube(...p);}
                            catch(e) {alert(p); window.location.reload();}// . . .
                            id++;
                            coords.splice(l, 1);
                        }
                    }
                }
                let tLength2 = ctx.measureText('i don\'t remember what this one is called');
                if (mouse.x < (rCanvas.width / 2) + tLength1.width / 2 && mouse.x > (rCanvas.width / 2) - tLength1.width / 2 && mouse.y < 2 * (rCanvas.height / 3) + 8 && mouse.y > 2 * (rCanvas.height / 3) - 42) {
                    start = true;
                    gameMode = 2;
                    coords = [];
                    for (var i = -0.5; i < 1; i++) { //making a new cube
                        for (var j = -0.5; j < 1; j++) {
                            for (var k = -0.5; k < 1; k++) {
                                coords.push([i, j, k]);
                            }
                        }
                    }
                    imagesLeft.fill(4);
                    imagesLeft2 = [...imagesLeft.keys()];
                    let id = 1;
                    for (var n = 1; n < 5; n++) {
                        var q = imagesLeft2[Math.floor(Math.random() * imagesLeft2.length)];
                        imagesLeft[q] -= 2;
                        if (imagesLeft[q] == 0) {
                            imagesLeft2 = imagesLeft2.filter(a => a != q);
                        }
                        for (var u = 0; u < 2; u++) {
                            let l = Math.floor(Math.random() * coords.length),
                                m = coords[l],
                                p = [...m, textures[q], gl, id, q]; //shh this fixes a bug so it's fine
                            try {new cube(...p);}
                            catch(e) {alert(p); window.location.reload();}// . . .
                            id++;
                            coords.splice(l, 1);
                            //otherPositions[JSON.stringify(m)] = false;
                            var z = otherPositions.indexOf(m);
                            otherPositions.splice(m, 1);
                            //otherPositions = otherPositions.filter(a => a[0] != m[0] && a[1] != m[1
                        }
                    }
                    addThen = tThen;
                }
                /*let tLength1 = ctx.measureText('Standard');
            ctx.fillText('Standard', (rCanvas.width / 2) - (tLength1.width / 2), (rCanvas.height / 3));
            ctx.strokeRect((rCanvas.width / 2) - (tLength1.width / 2), (rCanvas.height / 3) - 42, tLength1.width, 50);
            let tLength2 = ctx.measureText('i don\'t remember what this one is called');
            ctx.fillText('i don\'t remember what this one is called', (rCanvas.width / 2) - (tLength2.width / 2), 2 * (rCanvas.height / 3));
            ctx.strokeRect((rCanvas.width / 2) - (tLength2.width / 2), 2 * (rCanvas.height / 3) - 42, tLength2.width, 50);*/
            }
            else if (!resume) { //clicks in the pause menu
                let tLength = ctx.measureText('Resume');
                if (mouse.x < (rCanvas.width / 2) + tLength.width / 2 && mouse.x > (rCanvas.width / 2) - tLength.width / 2 && mouse.y < (rCanvas.height / 2) + 8 - 75 && mouse.y > (rCanvas.height / 2) - 42 - 75) {
                    resume = true;
                }
                tLength = ctx.measureText('Restart Cube');
                if (mouse.x < (rCanvas.width / 2) + tLength.width / 2 && mouse.x > (rCanvas.width / 2) - tLength.width / 2 && mouse.y < (rCanvas.height / 2) + 8 && mouse.y > (rCanvas.height / 2) - 42) {
                    if (gameMode == 1) {
                        cubelist = [...renderlist]; //putting all of the cubes back
                        for (cube in cubelist) {
                            cubelist[cube].id = cubelist[cube].oid; //basically resetting all of the ids (since they change for a good reason)
                        }
                    }
                    else if (gameMode == 2) {
                        otherPositions = [];
                        for (var i = -2.5; i < 3; i++) {
                            for (var j = -2.5; j < 3; j++) {
                                for (var k = -2.5; k < 3; k++) {
                                    //otherPositions[JSON.stringify([i, j, k])] = true;
                                    otherPositions.push([i, j, k]);
                                    //coords.push([i, j, k]);
                                }
                            }
                        }
                        coords = [];
                        for (var i = -0.5; i < 1; i++) { //making a new cube
                            for (var j = -0.5; j < 1; j++) {
                                for (var k = -0.5; k < 1; k++) {
                                    coords.push([i, j, k]);
                                }
                            }
                        }
                        imagesLeft.fill(4);
                        imagesLeft2 = [...imagesLeft.keys()];
                        let id = 1;
                        for (var n = 1; n < 5; n++) {
                            var q = imagesLeft2[Math.floor(Math.random() * imagesLeft2.length)];
                            imagesLeft[q] -= 2;
                            if (imagesLeft[q] == 0) {
                                imagesLeft2 = imagesLeft2.filter(a => a != q);
                            }
                            for (var u = 0; u < 2; u++) {
                                let l = Math.floor(Math.random() * coords.length),
                                    m = coords[l],
                                    p = [...m, textures[q], gl, id, q]; //shh this fixes a bug so it's fine
                                try {new cube(...p);}
                                catch(e) {alert(p); window.location.reload();}// . . .
                                id++;
                                coords.splice(l, 1);
                                //otherPositions[JSON.stringify(m)] = false;
                                var z = otherPositions.indexOf(m);
                                otherPositions.splice(m, 1);
                                //otherPositions = otherPositions.filter(a => a[0] != m[0] && a[1] != m[1
                            }
                        }
                        addThen = tThen;
                    }
                    score = 0;
                    time = 0;
                    resume = true;
                    totRot = glMatrix.quat.create();
                    combo = 1;
                    done = false;
                }
                tLength = ctx.measureText('New Cube');
                if (mouse.x < (rCanvas.width / 2) + tLength.width / 2 && mouse.x > (rCanvas.width / 2) - tLength.width / 2 && mouse.y < (rCanvas.height / 2) + 8 + 75 && mouse.y > (rCanvas.height / 2) - 42 + 75) {
                    if (gameMode == 1) {
                        cubelist = [];
                        renderlist = [];
                        coords = [];
                        for (var i = -2.5; i < 3; i++) { //making a new cube
                            for (var j = -2.5; j < 3; j++) {
                                for (var k = -2.5; k < 3; k++) {
                                    coords.push([i, j, k]);
                                }
                            }
                        }
                        let id = 1;
                        for (var n = 1; n < 55; n++) {
                            for (var u = 0; u < 4; u++) {
                                let l = Math.floor(Math.random() * coords.length),
                                    m = coords[l],
                                    p = [...m, textures[n - 1], gl, id, n]; //shh this fixes a bug so it's fine
                                try {new cube(...p);}
                                catch(e) {alert(p); window.location.reload();}// . . .
                                id++;
                                coords.splice(l, 1);
                            }
                        }
                    }
                    else if (gameMode == 2) {
                        otherPositions = [];
                        for (var i = -2.5; i < 3; i++) {
                            for (var j = -2.5; j < 3; j++) {
                                for (var k = -2.5; k < 3; k++) {
                                    //otherPositions[JSON.stringify([i, j, k])] = true;
                                    otherPositions.push([i, j, k]);
                                    //coords.push([i, j, k]);
                                }
                            }
                        }
                        coords = [];
                        for (var i = -0.5; i < 1; i++) { //making a new cube
                            for (var j = -0.5; j < 1; j++) {
                                for (var k = -0.5; k < 1; k++) {
                                    coords.push([i, j, k]);
                                }
                            }
                        }
                        imagesLeft.fill(4);
                        imagesLeft2 = [...imagesLeft.keys()];
                        let id = 1;
                        for (var n = 1; n < 5; n++) {
                            var q = imagesLeft2[Math.floor(Math.random() * imagesLeft2.length)];
                            imagesLeft[q] -= 2;
                            if (imagesLeft[q] == 0) {
                                imagesLeft2 = imagesLeft2.filter(a => a != q);
                            }
                            for (var u = 0; u < 2; u++) {
                                let l = Math.floor(Math.random() * coords.length),
                                    m = coords[l],
                                    p = [...m, textures[q], gl, id, q]; //shh this fixes a bug so it's fine
                                try {new cube(...p);}
                                catch(e) {alert(p); window.location.reload();}// . . .
                                id++;
                                coords.splice(l, 1);
                                //otherPositions[JSON.stringify(m)] = false;
                                var z = otherPositions.indexOf(m);
                                otherPositions.splice(m, 1);
                                //otherPositions = otherPositions.filter(a => a[0] != m[0] && a[1] != m[1
                            }
                        }
                        addThen = tThen;
                    }
                    resume = true;
                    score = 0;
                    time = 0;
                    totRot = glMatrix.quat.create();
                    combo = 1;
                    done = false;
                }
            }
        }
        ctx.font = "50px Courier New";
        tThen = 0;
        function makeTime(time) { // a quick little function to format milliseconds as hr:mn:sc.mil
            return ('00' + Math.floor(time / 3600000).toString()).slice(-2) + ':' + ('00' + (Math.floor(time / 60000) % 60).toString()).slice(-2) + ':' + ('00' + (Math.floor(time / 1000) % 60).toString()).slice(-2) + '.' + ('000' + (time | 0).toString()).slice(-3);
        }
        function timeUpdate(nowe) {
            if (start && resume) { //this is the ui for when the game is running
                if (!done && nowe - comboThen >= (5000 - (10 * combo)) && combo > 1) { //the logic for the combo decreasing
                    combo--;
                    comboThen = nowe;
                }
                ctx.clearRect(0, 0, rCanvas.width, rCanvas.height);
                ctx.fillStyle = '#00ff00';
                let tLength = ctx.measureText('Combo:'),
                    cLength = (5000 - (10 * combo)); //getting the sizes of things because why not
                !done && (dWidth = (combo == 1) ? (1) : ((comboThen - nowe + cLength) / cLength));
                ctx.fillRect(canvas.width - 300, 210, tLength.width * dWidth, 50);
                ctx.fillStyle = '#ffffff';
                ctx.fillText('Best Time:', 10, 50);
                (gameMode == 1) && (ctx.fillText(makeTime(bestTime), 10, 100));
                (gameMode == 2) && (ctx.fillText(makeTime(cBestTime), 10, 100));
                ctx.fillText('Time:', 10, 150);
                ctx.fillText(makeTime(time), 10, 200);
                ctx.fillText('Highscore:', canvas.width - 300, 50);
                (gameMode == 1) && (ctx.fillText(('00000000'+highScore.toString()).slice(-8), canvas.width - 300, 100));
                (gameMode == 2) && (ctx.fillText(('00000000'+cHighScore.toString()).slice(-8), canvas.width - 300, 100));
                ctx.fillText('Score:', canvas.width - 300, 150);
                ctx.fillText(('00000000'+score.toString()).slice(-8), canvas.width - 300, 200);
                ctx.fillText('Combo:', canvas.width - 300, 250);
                ctx.fillText('x' + combo.toString(), canvas.width - 300, 300);
                ctx.strokeStyle = '#666666';
                ctx.fillStyle = '#bbbbbb';
                ctx.lineWidth = 5;
                ctx.fillRect(rCanvas.width / 20, 17 * rCanvas.height / 20, rCanvas.width / 60, rCanvas.height / 10);
                ctx.strokeRect(rCanvas.width / 20, 17 * rCanvas.height / 20, rCanvas.width / 60, rCanvas.height / 10);
                ctx.fillRect(rCanvas.width / 40, 17 * rCanvas.height / 20, rCanvas.width / 60, rCanvas.height / 10);
                ctx.strokeRect(rCanvas.width / 40, 17 * rCanvas.height / 20, rCanvas.width / 60, rCanvas.height / 10);
                (loaded == 54) && (!done) && (time += dTime);
                
                if (gameMode == 2 && (nowe - addThen) >= addTime) {
                    let id = cubelist.length + 1;
                    if (id + (addCubes * 2) >= 6 ** 3) {
                        done = true; 
                        cubelist.forEach(cube => cube.explode()); 
                        window.localStorage.setItem('chighscore', Math.max(score, cHighScore).toString()); 
                        window.localStorage.setItem('cbesttime', Math.max(cBestTime, time).toString());
                    }
                    else {
                        for (var i = 0; i < addCubes; i++) {
                            var q = imagesLeft2[Math.floor(Math.random() * imagesLeft2.length)];
                            imagesLeft[q] -= 2;
                            if (imagesLeft[q] == 0) {
                                imagesLeft2 = imagesLeft2.filter(a => a != q);
                            }
                            for (var j = 0; j < 2; j++) {
                                let l = Math.floor(Math.random() * otherPositions.length),
                                    m = otherPositions[l],
                                    p = [...m, textures[q], gl, id, q]; //shh this fixes a bug so it's fine
                                try {new cube(...p);}
                                catch(e) {alert(p); window.location.reload();}// . . .
                                id++;
                                otherPositions.splice(l, 1);
                                //otherPositions[JSON.stringify(m)] = false;
                                //var z = otherPositions.indexOf(m);
                                //otherPositions.splice(m, 1);
                                //otherPositions = otherPositions.filter(a => a[0] != m[0] && a[1] != m[1
                            }
                        }
                        addCubes *= 1.05;
                        addThen = nowe;
                        addTime *= 1.01;
                    }
                }
                //done && (comboThen += dTime);
                if (funDOMType != 3) {
                    funDOM.forEach(i => document.body.removeChild(i));
                    funDOM = [];
                    funDOMType = 3;
                }
            }
            else if (!start && !done) { //the ui before the game starts
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, rCanvas.width, rCanvas.height);
                if (loaded < 54) { //while the textures are loading (drawing the loading bar)
                    ctx.font = "50px Courier New";
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(rCanvas.width / 4, 10 * rCanvas.height / 21, (loaded * rCanvas.width) / 108, 2 * rCanvas.height / 21);
                    ctx.strokeStyle = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeRect(rCanvas.width / 4, 10 * rCanvas.height / 21, rCanvas.width / 2, 2 * rCanvas.height / 21);
                    let tLength = ctx.measureText('Loading...');
                    ctx.fillText('Loading...', rCanvas.width / 2 - tLength.width / 2, 10 * rCanvas.height / 21 - 50);
                    if (funDOMType != 0) {
                        funDOM.forEach(i => document.body.removeChild(i));
                        funDOM = [];
                        funDOMType = 0;
                        var hover = document.createElement('div');
                        hover.style = `/*display: none;*/position: absolute; top: ${10 * rCanvas.height / 21 - 50}; left: ${rCanvas.width / 4}; width: ${rCanvas.width / 2}; height: 100`;
                        hover.title = 'loading, please wait!';
                        funDOM.push(hover);
                        funDOM.forEach(i => document.body.appendChild(i));
                    }
                }
                else { //after the textures have loaded (drawing the start button)
                    /*ctx.font = "50px Courier New";
            ctx.fillStyle = '#00ff00';
            ctx.strokeStyle = '#00ff00';
            let tLength = ctx.measureText('Start');
            ctx.fillText('Start', (rCanvas.width / 2) - (tLength.width / 2), (rCanvas.height / 2));
            ctx.strokeRect((rCanvas.width / 2) - (tLength.width / 2), (rCanvas.height / 2) - 42, tLength.width, 50);*/

                    ctx.font = "50px Courier New";
                    ctx.fillStyle = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    let tLength1 = ctx.measureText('Standard');
                    ctx.fillText('Standard', (rCanvas.width / 2) - (tLength1.width / 2), (rCanvas.height / 3));
                    ctx.strokeRect((rCanvas.width / 2) - (tLength1.width / 2), (rCanvas.height / 3) - 42, tLength1.width, 50);
                    let tLength2 = ctx.measureText('i don\'t remember what this one is called');
                    ctx.fillText('i don\'t remember what this one is called', (rCanvas.width / 2) - (tLength2.width / 2), 2 * (rCanvas.height / 3));
                    ctx.strokeRect((rCanvas.width / 2) - (tLength2.width / 2), 2 * (rCanvas.height / 3) - 42, tLength2.width, 50);
                    if (funDOMType != 1) {
                        funDOM.forEach(i => document.body.removeChild(i));
                        funDOM = [];
                        funDOMType = 1;
                        var hover1 = document.createElement('div');
                        hover1.style = `/*display: none;*/position: absolute; top: ${(rCanvas.height / 3) - 42}; left: ${(rCanvas.width / 2) - (tLength1.width / 2)}; width: ${tLength1.width}; height: 50`;
                        hover1.title = 'just a standard cube';
                        funDOM.push(hover1);
                        var hover2 = document.createElement('div');
                        hover2.style = `/*display: none;*/position: absolute; top: ${2 * (rCanvas.height / 3) - 42}; left: ${(rCanvas.width / 2) - (tLength2.width / 2)}; width: ${tLength2.width}; height: 50`;
                        hover2.title = 'uhhhhhhhhhhhhhhhhhhhhhh';
                        funDOM.push(hover2);
                        funDOM.forEach(i => document.body.appendChild(i));
                    }
                }
            }
            else if (!resume) { //drawing the pause menu
                ctx.lineWidth = 1;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, rCanvas.width, rCanvas.height);
                ctx.font = "50px Courier New";
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#00ff00';
                let tLength1 = ctx.measureText('Resume');
                ctx.fillText('Resume', (rCanvas.width / 2) - (tLength1.width / 2), (rCanvas.height / 2) - 75);
                ctx.strokeRect((rCanvas.width / 2) - (tLength1.width / 2), (rCanvas.height / 2) - 42 - 75, tLength1.width, 50);
                let tLength2 = ctx.measureText('Restart Cube');
                ctx.fillText('Restart Cube', (rCanvas.width / 2) - (tLength2.width / 2), (rCanvas.height / 2));
                ctx.strokeRect((rCanvas.width / 2) - (tLength2.width / 2), (rCanvas.height / 2) - 42, tLength2.width, 50);
                let tLength3 = ctx.measureText('New Cube');
                ctx.fillText('New Cube', (rCanvas.width / 2) - (tLength3.width / 2), (rCanvas.height / 2) + 75);
                ctx.strokeRect((rCanvas.width / 2) - (tLength3.width / 2), (rCanvas.height / 2) - 42 + 75, tLength3.width, 50);
                comboThen += dTime;
                (gameMode == 2) && (addThen += dTime);
                if (funDOMType != 2) {
                    funDOM.forEach(i => document.body.removeChild(i));
                    funDOM = [];
                    funDOMType = 2;
                    var hover1 = document.createElement('div');
                    hover1.style = `/*display: none;*/position: absolute; top: ${(rCanvas.height / 2) - 42 - 75}; left: ${(rCanvas.width / 2) - (tLength1.width / 2)}; width: ${tLength1.width}; height: 50`;
                    hover1.title = 'resume game';
                    funDOM.push(hover1);
                    var hover2 = document.createElement('div');
                    hover2.style = `/*display: none;*/position: absolute; top: ${(rCanvas.height / 2) - 42}; left: ${(rCanvas.width / 2) - (tLength2.width / 2)}; width: ${tLength2.width}; height: 50`;
                    (gameMode == 1) && (hover2.title = 'restart the current cube, and reset the time, score, and combo');
                    (gameMode == 2) && (hover2.title = 'does the same thing as new cube. creates an entirely new cube, with different randomness');
                    funDOM.push(hover2);
                    var hover3 = document.createElement('div');
                    hover3.style = `/*display: none;*/position: absolute; top: ${(rCanvas.height / 2) - 42 + 75}; left: ${(rCanvas.width / 2) - (tLength3.width / 2)}; width: ${tLength3.width}; height: 50`;
                    hover3.title = 'start a new cube';
                    funDOM.push(hover3);
                    funDOM.forEach(i => document.body.appendChild(i));
                }
            }


            dTime = nowe - tThen; //updating the time
            tThen = nowe;

            if (cubelist.length == 0) {
                if (gameMode == 1) {(done == false) && (done = true, renderlist.forEach(cube => cube.explode()), window.localStorage.setItem('highscore', Math.max(score, highScore).toString()), window.localStorage.setItem('besttime', Math.min(bestTime, time).toString()))}
                if (gameMode == 2) {
                    /*let id = 1;
            for (var n = 1; n < 5; n++) {
                var q = imagesLeft2[Math.floor(Math.random() * imagesLeft2.length)];
                imagesLeft[q] -= 2;
                if (imagesLeft[q] == 0) {
                    imagesLeft2 = imagesLeft2.filter(a => a != q);
                }
                for (var u = 0; u < 2; u++) {
                    let l = Math.floor(Math.random() * coords.length),
                        m = coords[l],
                        p = [...m, textures[q - 1], gl, id, q]; //shh this fixes a bug so it's fine
                    try {new cube(...p);}
                    catch(e) {alert(p); window.location.reload();}// . . .
                    id++;
                    coords.splice(l, 1);
                    //otherPositions[JSON.stringify(m)] = false;
                    var z = otherPositions.indexOf(m);
                    otherPositions.splice(m, 1);
                    //otherPositions = otherPositions.filter(a => a[0] != m[0] && a[1] != m[1
                }
            }*/
                    let id = 1;
                    for (var i = 0; i < addCubes; i++) {
                        var q = imagesLeft2[Math.floor(Math.random() * imagesLeft2.length)];
                        imagesLeft[q] -= 2;
                        if (imagesLeft[q] == 0) {
                            imagesLeft2 = imagesLeft2.filter(a => a != q);
                        }
                        for (var j = 0; j < 2; j++) {
                            let l = Math.floor(Math.random() * otherPositions.length),
                                m = otherPositions[l],
                                p = [...m, textures[q], gl, id, q]; //shh this fixes a bug so it's fine
                            try {new cube(...p);}
                            catch(e) {alert(p); window.location.reload();}// . . .
                            id++;
                            otherPositions.splice(l, 1);
                            //otherPositions[JSON.stringify(m)] = false;
                            //var z = otherPositions.indexOf(m);
                            //otherPositions.splice(m, 1);
                            //otherPositions = otherPositions.filter(a => a[0] != m[0] && a[1] != m[1
                        }
                    }
                    addCubes *= 1.05;
                    addThen = nowe;
                    addTime *= 1.01;
                }
            } //doing the end
            requestAnimationFrame(timeUpdate)} // L O O P
        requestAnimationFrame(timeUpdate);
        //})()
    </script>
